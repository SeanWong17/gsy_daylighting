<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ¥¼ç›˜è§„åˆ’å›¾é…ç½®å™¨</title>
    <style>
        body { display: flex; margin: 0; height: 100vh; font-family: 'Microsoft YaHei', sans-serif; overflow: hidden; }
        
        /* å·¦ä¾§ç”»å¸ƒåŒº */
        #canvas-wrapper {
            flex: 1;
            background: #e0e0e0;
            position: relative;
            overflow: auto; /* å…è®¸å¤§å›¾æ»šåŠ¨ */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { box-shadow: 0 0 10px rgba(0,0,0,0.2); cursor: crosshair; background: white; }

        /* å³ä¾§è¾¹æ  */
        #sidebar {
            width: 320px;
            background: #f8f9fa;
            border-left: 1px solid #ccc;
            padding: 20px;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        h3 { margin-top: 0; color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
        .step { margin-bottom: 20px; padding: 15px; background: #fff; border-radius: 6px; border: 1px solid #ddd; }
        .step.active { border-color: #007bff; box-shadow: 0 0 5px rgba(0,123,255,0.2); }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 13px; }
        input[type="text"], input[type="number"], input[type="file"] {
            width: 100%; box-sizing: border-box; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;
        }
        
        button {
            width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 5px; font-size: 14px;
        }
        button:hover { background: #0069d9; }
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #5a6268; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        #building-list { flex: 1; overflow-y: auto; border-top: 1px solid #eee; margin-top: 10px; }
        .building-item { padding: 8px; border-bottom: 1px solid #eee; font-size: 12px; display: flex; justify-content: space-between; }
        .building-item:hover { background: #f1f1f1; }
        .del-btn { color: red; cursor: pointer; font-weight: bold; }

        .status-bar { margin-top: 10px; font-size: 12px; color: #666; text-align: center; }
    </style>
</head>
<body>

<div id="canvas-wrapper">
    <canvas id="editorCanvas"></canvas>
</div>

<div id="sidebar">
    <h3>ğŸ› ï¸ æ¥¼ç›˜æ•°æ®é…ç½®</h3>

    <div class="step" id="step-upload">
        <label>1. ä¸Šä¼ è§„åˆ’å›¾/æ€»å¹³å›¾</label>
        <input type="file" id="fileInput" accept="image/*">
    </div>

    <div class="step" id="step-scale">
        <label>2. æ ‡å®šæ¯”ä¾‹å°º</label>
        <div style="font-size:12px; color:#666; margin-bottom:5px;">
            çŠ¶æ€: <span id="scaleStatus">æœªæ ‡å®š</span>
        </div>
        <button id="btnStartScale" disabled>å¼€å§‹æ ‡å®š (ç‚¹å‡»ä¸¤ç‚¹)</button>
        <div id="scaleInputArea" style="display:none; margin-top:5px;">
            <label>ä¸¤ç‚¹é—´å®é™…è·ç¦» (ç±³):</label>
            <input type="number" id="realDistance" value="50">
            <button id="btnConfirmScale" class="secondary">ç¡®è®¤æ¯”ä¾‹</button>
        </div>
    </div>

    <div class="step active" id="step-draw">
        <label>3. ç»˜åˆ¶æ¥¼æ ‹</label>
        <div style="font-size:12px; color:#666; margin-bottom:5px;">
            æ“ä½œ: å·¦é”®åŠ ç‚¹ï¼Œå³é”®é—­åˆç»“æŸã€‚
        </div>
        <button id="btnDrawMode" class="secondary">å½“å‰: æµè§ˆæ¨¡å¼</button>
    </div>

    <label>å·²æ·»åŠ æ¥¼æ ‹ (<span id="countDisplay">0</span>)</label>
    <div id="building-list"></div>
    
    <button id="btnExport" style="margin-top: 10px; background: #28a745;">å¯¼å‡º JSON é…ç½®</button>
</div>

<script>
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    
    // çŠ¶æ€å˜é‡
    let image = new Image();
    let isImageLoaded = false;
    let scaleRatio = 0; // 1åƒç´  = å¤šå°‘ç±³
    let buildings = []; // å­˜å‚¨æ‰€æœ‰æ¥¼æ ‹æ•°æ®
    
    // äº¤äº’æ¨¡å¼: 'idle', 'scaling_p1', 'scaling_p2', 'drawing'
    let mode = 'idle'; 
    
    // ä¸´æ—¶æ•°æ®
    let scalePoints = []; // æ ‡å®šç”¨çš„ä¸¤ä¸ªç‚¹
    let currentPoly = []; // å½“å‰æ­£åœ¨ç”»çš„å¤šè¾¹å½¢ç‚¹é›†
    let mousePos = {x:0, y:0};

    // 1. å›¾ç‰‡åŠ è½½
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            image.onload = () => {
                canvas.width = image.width;
                canvas.height = image.height;
                isImageLoaded = true;
                document.getElementById('btnStartScale').disabled = false;
                draw();
            };
            image.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // 2. æ¸²æŸ“å¾ªç¯ (ç®€å•çš„é‡ç»˜)
    function draw() {
        // æ¸…ç©º
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!isImageLoaded) {
            ctx.font = "20px Arial";
            ctx.fillStyle = "#999";
            ctx.fillText("è¯·åœ¨å³ä¾§ä¸Šä¼ å›¾ç‰‡", 50, 50);
            return;
        }

        // ç”»åº•å›¾
        ctx.drawImage(image, 0, 0);

        // ç”»å·²å­˜åœ¨çš„æ¥¼æ ‹
        buildings.forEach(b => {
            drawPolygon(b.points, 'rgba(0, 123, 255, 0.3)', '#007bff');
            // æ ‡è®°æ¥¼å·
            const center = getPolygonCenter(b.points);
            ctx.fillStyle = "white";
            ctx.font = "bold 14px Arial";
            ctx.fillText(b.name, center.x - 10, center.y);
        });

        // ç”»æ ‡å®šçº¿
        if (scalePoints.length > 0) {
            ctx.beginPath();
            ctx.arc(scalePoints[0].x, scalePoints[0].y, 5, 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
        }
        if (scalePoints.length === 2) {
            ctx.beginPath();
            ctx.arc(scalePoints[1].x, scalePoints[1].y, 5, 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
            // è¿çº¿
            ctx.beginPath();
            ctx.moveTo(scalePoints[0].x, scalePoints[0].y);
            ctx.lineTo(scalePoints[1].x, scalePoints[1].y);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ç”»å½“å‰æ­£åœ¨ç»˜åˆ¶çš„å¤šè¾¹å½¢
        if (currentPoly.length > 0) {
            // ç”»ç‚¹å’Œè¿çº¿
            ctx.beginPath();
            ctx.moveTo(currentPoly[0].x, currentPoly[0].y);
            for (let i = 1; i < currentPoly.length; i++) {
                ctx.lineTo(currentPoly[i].x, currentPoly[i].y);
            }
            // é¼ æ ‡è·Ÿéšçº¿
            ctx.lineTo(mousePos.x, mousePos.y);
            
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç”»ç‚¹
            ctx.fillStyle = '#28a745';
            currentPoly.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            });
        }
    }

    // è¾…åŠ©ï¼šç”»å¤šè¾¹å½¢
    function drawPolygon(points, fillColor, strokeColor) {
        if(points.length < 3) return;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // è¾…åŠ©ï¼šè®¡ç®—ä¸­å¿ƒç‚¹ç”¨äºæ˜¾ç¤ºæ–‡å­—
    function getPolygonCenter(points) {
        let x = 0, y = 0;
        points.forEach(p => { x += p.x; y += p.y; });
        return { x: x / points.length, y: y / points.length };
    }

    // 3. äº¤äº’é€»è¾‘
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        if (mode === 'drawing') draw();
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!isImageLoaded) return;
        // å·¦é”®ç‚¹å‡»
        if (e.button === 0) {
            const rect = canvas.getBoundingClientRect();
            const p = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            if (mode === 'scaling') {
                scalePoints.push(p);
                if (scalePoints.length === 2) {
                    mode = 'idle'; // æš‚åœç­‰å¾…è¾“å…¥è·ç¦»
                    document.getElementById('scaleInputArea').style.display = 'block';
                }
                draw();
            } else if (mode === 'drawing') {
                currentPoly.push(p);
                draw();
            }
        }
        // å³é”®ç‚¹å‡» (ç»“æŸç»˜åˆ¶)
        else if (e.button === 2) {
            if (mode === 'drawing' && currentPoly.length > 2) {
                finishPolygon();
            }
        }
    });

    // ç¦ç”¨å³é”®èœå•
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // ç»“æŸç»˜åˆ¶ä¸€ä¸ªæ¥¼æ ‹
    function finishPolygon() {
        if (scaleRatio === 0) {
            alert("è¯·å…ˆæ ‡å®šæ¯”ä¾‹å°ºï¼");
            currentPoly = [];
            draw();
            return;
        }

        // ç®€å•çš„ prompt è¾“å…¥ (å®é™…é¡¹ç›®ä¸­å¯ä»¥ç”¨æ¨¡æ€æ¡†)
        const name = prompt("è¯·è¾“å…¥æ¥¼å· (ä¾‹å¦‚: 1å·æ¥¼):", (buildings.length + 1) + "å·æ¥¼");
        if (!name) return; // å–æ¶ˆ

        const floors = prompt("è¯·è¾“å…¥æ€»å±‚æ•°:", "33");
        const heightPerFloor = prompt("è¯·è¾“å…¥å±‚é«˜ (ç±³):", "3");
        
        const b = {
            id: Date.now(),
            name: name,
            floors: parseInt(floors),
            floorHeight: parseFloat(heightPerFloor),
            points: [...currentPoly] // å¤åˆ¶æ•°ç»„
        };
        
        buildings.push(b);
        currentPoly = []; // æ¸…ç©º
        updateList();
        draw();
    }

    // 4. æŒ‰é’®é€»è¾‘
    
    // æ ‡å®š
    document.getElementById('btnStartScale').addEventListener('click', () => {
        scalePoints = [];
        mode = 'scaling';
        document.getElementById('scaleStatus').innerText = "è¯·åœ¨å›¾ä¸­ç‚¹å‡»ä¸¤ç‚¹ (å¦‚æ ‡å°ºæˆ–å·²çŸ¥è¾¹é•¿)";
        document.getElementById('scaleInputArea').style.display = 'none';
        draw();
    });

    document.getElementById('btnConfirmScale').addEventListener('click', () => {
        const distPx = Math.hypot(scalePoints[1].x - scalePoints[0].x, scalePoints[1].y - scalePoints[0].y);
        const distReal = parseFloat(document.getElementById('realDistance').value);
        
        scaleRatio = distReal / distPx; // 1åƒç´  = x ç±³
        
        document.getElementById('scaleStatus').innerText = `å·²æ ‡å®š (1px â‰ˆ ${scaleRatio.toFixed(4)}m)`;
        document.getElementById('scaleInputArea').style.display = 'none';
        
        // è‡ªåŠ¨åˆ‡æ¢åˆ°ç»˜åˆ¶æ¨¡å¼
        toggleDrawMode(true);
    });

    // ç»˜åˆ¶æ¨¡å¼åˆ‡æ¢
    const btnDrawMode = document.getElementById('btnDrawMode');
    btnDrawMode.addEventListener('click', () => {
        if (mode === 'drawing') {
            toggleDrawMode(false);
        } else {
            toggleDrawMode(true);
        }
    });

    function toggleDrawMode(active) {
        if (active) {
            mode = 'drawing';
            btnDrawMode.innerText = "å½“å‰: âœï¸ æ­£åœ¨ç»˜åˆ¶ (å³é”®ç»“æŸ)";
            btnDrawMode.style.background = "#28a745"; // Green
            btnDrawMode.style.color = "white";
        } else {
            mode = 'idle';
            btnDrawMode.innerText = "å½“å‰: âœ‹ æµè§ˆæ¨¡å¼";
            btnDrawMode.style.background = "#6c757d"; // Grey
            currentPoly = [];
            draw();
        }
    }

    // æ›´æ–°åˆ—è¡¨
    function updateList() {
        const list = document.getElementById('building-list');
        list.innerHTML = '';
        document.getElementById('countDisplay').innerText = buildings.length;

        buildings.forEach((b, index) => {
            const div = document.createElement('div');
            div.className = 'building-item';
            div.innerHTML = `
                <span><b>${b.name}</b> (${b.floors}å±‚)</span>
                <span class="del-btn" onclick="removeBuilding(${index})">Ã—</span>
            `;
            list.appendChild(div);
        });
    }

    window.removeBuilding = function(index) {
        if(confirm('ç¡®å®šåˆ é™¤è¯¥æ¥¼æ ‹å—ï¼Ÿ')) {
            buildings.splice(index, 1);
            updateList();
            draw();
        }
    };

    // 5. å¯¼å‡ºåŠŸèƒ½
    document.getElementById('btnExport').addEventListener('click', () => {
        if (buildings.length === 0) {
            alert("æ²¡æœ‰æ•°æ®å¯å¯¼å‡º");
            return;
        }

        // è®¡ç®—æ•´ä¸ªåœºæ™¯çš„åŒ…å›´ç›’ä¸­å¿ƒï¼Œç”¨äºå°†åæ ‡å½’ä¸€åŒ–åˆ° (0,0)
        // è¿™å¯¹ Three.js å¾ˆé‡è¦ï¼Œå¦åˆ™æ¨¡å‹ä¼šåç¦»ä¸­å¿ƒå¾ˆè¿œ
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        buildings.forEach(b => {
            b.points.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            });
        });
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const exportData = {
            version: 1.0,
            scaleRatio: scaleRatio, // 1px = ? meters
            origin: { x: centerX, y: centerY }, // åŸå§‹å›¾ç‰‡çš„ä¸­å¿ƒç‚¹åæ ‡
            buildings: buildings.map(b => ({
                name: b.name,
                floors: b.floors,
                floorHeight: b.floorHeight,
                totalHeight: b.floors * b.floorHeight,
                // è½¬æ¢åæ ‡ï¼š1. ä»¥ä¸­å¿ƒä¸ºåŸç‚¹ 2. ä¹˜ä»¥æ¯”ä¾‹å°ºè½¬ä¸ºç±³ 3. Yè½´ç¿»è½¬(Canvas Yå‘ä¸‹, ThreeJS Zå‘ä¸‹/å—)
                // æ³¨æ„ï¼šCanvasä¸­ yå‘ä¸‹ï¼ŒThreejsä¸­æˆ‘ä»¬é€šå¸¸æŠŠè§„åˆ’å›¾çš„ y æ˜ å°„ä¸º z (å—)
                shape: b.points.map(p => ({
                    x: (p.x - centerX) * scaleRatio,
                    y: (p.y - centerY) * scaleRatio 
                }))
            }))
        };

        // ä¸‹è½½æ–‡ä»¶
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "buildings_config.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    });

</script>
</body>
</html>
